# Gemini Project Guidelines

You are an AI coding assistant that helps develop a React + TypeScript + Redux Toolkit project following the **Feature-Sliced Design (FSD)** methodology.

Always follow these principles and explain your reasoning when suggesting changes.

---

## üèóÔ∏è Architecture

- Follow **Feature-Sliced Design** strictly.
- Folder structure: `app/`, `pages/`, `features/`, `entities/`, `shared/`, `widgets/`.
- Each slice must have its own `index.ts` for public API and isolated internal structure.
- Avoid cross-imports between slices. Communication should happen only through public APIs.
- Place reusable logic in `shared/` or `entities/` when it‚Äôs truly cross-slice.

---

## ‚öôÔ∏è Tech Stack

- **Framework:** React (functional components only)
- **Language:** TypeScript (`strict` mode)
- **State management:** Redux Toolkit
- **Data fetching:** RTK Query
- **Styling:** CSS Modules + SCSS
- **Testing:** Vitest + React Testing Library
- **Formatting:** ESLint + Prettier (project configs must be respected)
- **Documentation:** Use JSDoc for functions, utilities, and hooks

---

## üß© Coding Guidelines

- Prefer `const` over `let`.
- Use named exports only (no `default` exports).
- Never use `any`, `Function`, or untyped parameters.
- Use `useMemo`, `useCallback`, and `memo` where performance benefits are clear.
- Avoid logic in JSX markup; extract it to variables or hooks.
- Avoid using deprecated functions or APIs ‚Äî always use the latest stable React and TypeScript syntax.
- Always use async/await over `.then()` chains.
- Keep functions pure and predictable.
- Ensure UI logic and data logic are separated (FSD principle).

---

## üß† Redux & RTK Query Rules

- Create slices per domain feature (`featureName/model/slice.ts`).
- Use RTK Query for all API interactions.
- Keep selectors and actions grouped by slice.
- Prefer `createAsyncThunk` for async logic outside RTK Query.

---

## üé® Styling

- Use `.module.scss` files for each component.
- Follow BEM-like naming inside CSS modules.
- Avoid inline styles unless absolutely necessary.
- Keep styles local to components; do not create global CSS unless required for resets.

---

## üß™ Testing

- Write tests for all new logic and components.
- Use **Vitest** for unit tests and **React Testing Library** for UI.
- Test public API of slices and exported components.
- Use mock service workers for RTK Query where necessary.

---

## üóÇÔ∏è Documentation

- Add **JSDoc** for:
    - Custom hooks
    - Utilities
    - Complex functions
    - Reducers and thunks
- Prefer concise but meaningful descriptions.

---

## üí¨ Assistant Behavior

When suggesting code:
- Follow all above rules by default.
- If an alternative approach exists, **explain the reasoning** behind your suggestion.
- Warn if you detect deprecated methods, missing typings, or architectural violations.
- Provide concise, production-grade examples.
- Never use deprecated React, TypeScript, or Redux APIs.

---

## ‚úÖ Example

```tsx
import { memo } from 'react';
import styles from './UserCard.module.scss';

/**
 * Displays user info in a compact format.
 * @param {Object} props
 * @param {string} props.name - User's full name
 * @param {string} props.avatarUrl - Link to user avatar image
 */
export const UserCard = memo(function UserCard({ name, avatarUrl }: {
  name: string;
  avatarUrl: string;
}) {
  return (
    <div className={styles.card}>
      <img src={avatarUrl} alt={name} className={styles.avatar} />
      <span className={styles.name}>{name}</span>
    </div>
  );
});
```

## üí° Note: This project must remain consistent with the above conventions.
Gemini should detect and warn about:

- Cross-slice imports

- Deprecated APIs

- Missing type definitions

- Violations of FSD boundaries